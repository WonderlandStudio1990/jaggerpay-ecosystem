/* tslint:disable */
/* eslint-disable */
/**
 * Monite API
 * Complete Monite API specification
 *
 * The version of the OpenAPI document: 2024-01-31
 * Contact: support@wonderpaid.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line1': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'type': EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'email': string;
    /**
     * 
     * @type {Address}
     * @memberof Entity
     */
    'address': Address;
    /**
     * 
     * @type {Organization}
     * @memberof Entity
     */
    'organization'?: Organization;
    /**
     * 
     * @type {Individual}
     * @memberof Entity
     */
    'individual'?: Individual;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'status'?: EntityStatusEnum;
}

export const EntityTypeEnum = {
    Organization: 'organization',
    Individual: 'individual'
} as const;

export type EntityTypeEnum = typeof EntityTypeEnum[keyof typeof EntityTypeEnum];
export const EntityStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type EntityStatusEnum = typeof EntityStatusEnum[keyof typeof EntityStatusEnum];

/**
 * 
 * @export
 * @interface EntityCreate
 */
export interface EntityCreate {
    /**
     * 
     * @type {string}
     * @memberof EntityCreate
     */
    'type': EntityCreateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityCreate
     */
    'email': string;
    /**
     * 
     * @type {Address}
     * @memberof EntityCreate
     */
    'address': Address;
    /**
     * 
     * @type {Organization}
     * @memberof EntityCreate
     */
    'organization'?: Organization;
    /**
     * 
     * @type {Individual}
     * @memberof EntityCreate
     */
    'individual'?: Individual;
}

export const EntityCreateTypeEnum = {
    Organization: 'organization',
    Individual: 'individual'
} as const;

export type EntityCreateTypeEnum = typeof EntityCreateTypeEnum[keyof typeof EntityCreateTypeEnum];

/**
 * 
 * @export
 * @interface EntityUpdate
 */
export interface EntityUpdate {
    /**
     * 
     * @type {string}
     * @memberof EntityUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {Address}
     * @memberof EntityUpdate
     */
    'address'?: Address;
    /**
     * 
     * @type {Organization}
     * @memberof EntityUpdate
     */
    'organization'?: Organization;
    /**
     * 
     * @type {Individual}
     * @memberof EntityUpdate
     */
    'individual'?: Individual;
}
/**
 * 
 * @export
 * @interface Individual
 */
export interface Individual {
    /**
     * 
     * @type {string}
     * @memberof Individual
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof Individual
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof Individual
     */
    'tax_id'?: string;
}
/**
 * 
 * @export
 * @interface ListEntities200Response
 */
export interface ListEntities200Response {
    /**
     * 
     * @type {Array<Entity>}
     * @memberof ListEntities200Response
     */
    'data'?: Array<Entity>;
    /**
     * 
     * @type {string}
     * @memberof ListEntities200Response
     */
    'pagination_token'?: string;
}
/**
 * 
 * @export
 * @interface MoniteBankAccount
 */
export interface MoniteBankAccount {
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccount
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccount
     */
    'bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccount
     */
    'bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccount
     */
    'account_holder_name': string;
}
/**
 * 
 * @export
 * @interface MoniteBankAccountResponse
 */
export interface MoniteBankAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'account_holder_name': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteBankAccountResponse
     */
    'status'?: MoniteBankAccountResponseStatusEnum;
}

export const MoniteBankAccountResponseStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type MoniteBankAccountResponseStatusEnum = typeof MoniteBankAccountResponseStatusEnum[keyof typeof MoniteBankAccountResponseStatusEnum];

/**
 * 
 * @export
 * @interface MoniteEntitySettings
 */
export interface MoniteEntitySettings {
    /**
     * 
     * @type {string}
     * @memberof MoniteEntitySettings
     */
    'default_currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MoniteEntitySettings
     */
    'vat_id_required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MoniteEntitySettings
     */
    'approval_required'?: boolean;
}
/**
 * 
 * @export
 * @interface MonitePayableCreate
 */
export interface MonitePayableCreate {
    /**
     * 
     * @type {MonitePayableCreateAmount}
     * @memberof MonitePayableCreate
     */
    'amount': MonitePayableCreateAmount;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableCreate
     */
    'due_date': string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableCreate
     */
    'counterpart_id': string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableCreate
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface MonitePayableCreateAmount
 */
export interface MonitePayableCreateAmount {
    /**
     * 
     * @type {string}
     * @memberof MonitePayableCreateAmount
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof MonitePayableCreateAmount
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface MonitePayableResponse
 */
export interface MonitePayableResponse {
    /**
     * 
     * @type {MonitePayableCreateAmount}
     * @memberof MonitePayableResponse
     */
    'amount': MonitePayableCreateAmount;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'due_date': string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'counterpart_id': string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitePayableResponse
     */
    'status'?: MonitePayableResponseStatusEnum;
}

export const MonitePayableResponseStatusEnum = {
    Draft: 'draft',
    Submitted: 'submitted',
    Approved: 'approved',
    Paid: 'paid',
    Canceled: 'canceled'
} as const;

export type MonitePayableResponseStatusEnum = typeof MonitePayableResponseStatusEnum[keyof typeof MonitePayableResponseStatusEnum];

/**
 * 
 * @export
 * @interface MoniteProjectSettings
 */
export interface MoniteProjectSettings {
    /**
     * 
     * @type {string}
     * @memberof MoniteProjectSettings
     */
    'default_currency'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MoniteProjectSettings
     */
    'available_currencies'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MoniteProjectSettings
     */
    'vat_id_required'?: boolean;
}
/**
 * 
 * @export
 * @interface MoniteReceivableCreate
 */
export interface MoniteReceivableCreate {
    /**
     * 
     * @type {MonitePayableCreateAmount}
     * @memberof MoniteReceivableCreate
     */
    'amount': MonitePayableCreateAmount;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableCreate
     */
    'due_date': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableCreate
     */
    'counterpart_id': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableCreate
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface MoniteReceivableResponse
 */
export interface MoniteReceivableResponse {
    /**
     * 
     * @type {MonitePayableCreateAmount}
     * @memberof MoniteReceivableResponse
     */
    'amount': MonitePayableCreateAmount;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'due_date': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'counterpart_id': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteReceivableResponse
     */
    'status'?: MoniteReceivableResponseStatusEnum;
}

export const MoniteReceivableResponseStatusEnum = {
    Draft: 'draft',
    Issued: 'issued',
    Paid: 'paid',
    Canceled: 'canceled'
} as const;

export type MoniteReceivableResponseStatusEnum = typeof MoniteReceivableResponseStatusEnum[keyof typeof MoniteReceivableResponseStatusEnum];

/**
 * 
 * @export
 * @interface MoniteRole
 */
export interface MoniteRole {
    /**
     * 
     * @type {string}
     * @memberof MoniteRole
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MoniteRole
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface MoniteRoleResponse
 */
export interface MoniteRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof MoniteRoleResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MoniteRoleResponse
     */
    'permissions': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MoniteRoleResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteRoleResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteRoleResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface MoniteVatId
 */
export interface MoniteVatId {
    /**
     * 
     * @type {string}
     * @memberof MoniteVatId
     */
    'country_code': string;
    /**
     * 
     * @type {string}
     * @memberof MoniteVatId
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MoniteWorkflow
 */
export interface MoniteWorkflow {
    /**
     * 
     * @type {string}
     * @memberof MoniteWorkflow
     */
    'name': string;
    /**
     * 
     * @type {Array<MoniteWorkflowStepsInner>}
     * @memberof MoniteWorkflow
     */
    'steps': Array<MoniteWorkflowStepsInner>;
}
/**
 * 
 * @export
 * @interface MoniteWorkflowResponse
 */
export interface MoniteWorkflowResponse {
    /**
     * 
     * @type {string}
     * @memberof MoniteWorkflowResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<MoniteWorkflowStepsInner>}
     * @memberof MoniteWorkflowResponse
     */
    'steps': Array<MoniteWorkflowStepsInner>;
    /**
     * 
     * @type {string}
     * @memberof MoniteWorkflowResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteWorkflowResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoniteWorkflowResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface MoniteWorkflowStepsInner
 */
export interface MoniteWorkflowStepsInner {
    /**
     * 
     * @type {string}
     * @memberof MoniteWorkflowStepsInner
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof MoniteWorkflowStepsInner
     */
    'config'?: object;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'legal_name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'tax_id'?: string;
}
/**
 * 
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'grant_type': TokenRequestGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'client_secret': string;
}

export const TokenRequestGrantTypeEnum = {
    ClientCredentials: 'client_credentials'
} as const;

export type TokenRequestGrantTypeEnum = typeof TokenRequestGrantTypeEnum[keyof typeof TokenRequestGrantTypeEnum];

/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in'?: number;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate an access token using client credentials
         * @summary Get access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (tokenRequest: TokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequest' is not null or undefined
            assertParamExists('getAccessToken', 'tokenRequest', tokenRequest)
            const localVarPath = `/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate an access token using client credentials
         * @summary Get access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(tokenRequest: TokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(tokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Generate an access token using client credentials
         * @summary Get access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(tokenRequest: TokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.getAccessToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Generate an access token using client credentials
     * @summary Get access token
     * @param {TokenRequest} tokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAccessToken(tokenRequest: TokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAccessToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankAccountsApi - axios parameter creator
 * @export
 */
export const BankAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new bank account
         * @summary Create bank account
         * @param {MoniteBankAccount} moniteBankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankAccount: async (moniteBankAccount: MoniteBankAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteBankAccount' is not null or undefined
            assertParamExists('createBankAccount', 'moniteBankAccount', moniteBankAccount)
            const localVarPath = `/v1/bank-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteBankAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all bank accounts
         * @summary List bank accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBankAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/bank-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankAccountsApi - functional programming interface
 * @export
 */
export const BankAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new bank account
         * @summary Create bank account
         * @param {MoniteBankAccount} moniteBankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBankAccount(moniteBankAccount: MoniteBankAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBankAccount(moniteBankAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.createBankAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all bank accounts
         * @summary List bank accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBankAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MoniteBankAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBankAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.listBankAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankAccountsApi - factory interface
 * @export
 */
export const BankAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankAccountsApiFp(configuration)
    return {
        /**
         * Create a new bank account
         * @summary Create bank account
         * @param {MoniteBankAccount} moniteBankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankAccount(moniteBankAccount: MoniteBankAccount, options?: RawAxiosRequestConfig): AxiosPromise<MoniteBankAccountResponse> {
            return localVarFp.createBankAccount(moniteBankAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bank accounts
         * @summary List bank accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBankAccounts(options?: RawAxiosRequestConfig): AxiosPromise<Array<MoniteBankAccountResponse>> {
            return localVarFp.listBankAccounts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankAccountsApi - object-oriented interface
 * @export
 * @class BankAccountsApi
 * @extends {BaseAPI}
 */
export class BankAccountsApi extends BaseAPI {
    /**
     * Create a new bank account
     * @summary Create bank account
     * @param {MoniteBankAccount} moniteBankAccount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public createBankAccount(moniteBankAccount: MoniteBankAccount, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).createBankAccount(moniteBankAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all bank accounts
     * @summary List bank accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public listBankAccounts(options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).listBankAccounts(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntitiesApi - axios parameter creator
 * @export
 */
export const EntitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new entity in Monite
         * @summary Create entity
         * @param {EntityCreate} entityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity: async (entityCreate: EntityCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityCreate' is not null or undefined
            assertParamExists('createEntity', 'entityCreate', entityCreate)
            const localVarPath = `/v1/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entity
         * @summary Delete entity
         * @param {string} entityId ID of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntity: async (entityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('deleteEntity', 'entityId', entityId)
            const localVarPath = `/v1/entities/{entity_id}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific entity
         * @summary Get entity by ID
         * @param {string} entityId ID of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity: async (entityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntity', 'entityId', entityId)
            const localVarPath = `/v1/entities/{entity_id}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all entities with pagination
         * @summary List entities
         * @param {ListEntitiesOrderEnum} [order] Sort order for results
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [paginationToken] Token for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities: async (order?: ListEntitiesOrderEnum, limit?: number, paginationToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing entity
         * @summary Update entity
         * @param {string} entityId ID of the entity
         * @param {EntityUpdate} entityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity: async (entityId: string, entityUpdate: EntityUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('updateEntity', 'entityId', entityId)
            // verify required parameter 'entityUpdate' is not null or undefined
            assertParamExists('updateEntity', 'entityUpdate', entityUpdate)
            const localVarPath = `/v1/entities/{entity_id}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new entity in Monite
         * @summary Create entity
         * @param {EntityCreate} entityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntity(entityCreate: EntityCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(entityCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.createEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an entity
         * @summary Delete entity
         * @param {string} entityId ID of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntity(entityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntity(entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.deleteEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific entity
         * @summary Get entity by ID
         * @param {string} entityId ID of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntity(entityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.getEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all entities with pagination
         * @summary List entities
         * @param {ListEntitiesOrderEnum} [order] Sort order for results
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [paginationToken] Token for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntities(order?: ListEntitiesOrderEnum, limit?: number, paginationToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEntities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntities(order, limit, paginationToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.listEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing entity
         * @summary Update entity
         * @param {string} entityId ID of the entity
         * @param {EntityUpdate} entityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntity(entityId: string, entityUpdate: EntityUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(entityId, entityUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.updateEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitiesApiFp(configuration)
    return {
        /**
         * Create a new entity in Monite
         * @summary Create entity
         * @param {EntityCreate} entityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(entityCreate: EntityCreate, options?: RawAxiosRequestConfig): AxiosPromise<Entity> {
            return localVarFp.createEntity(entityCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an entity
         * @summary Delete entity
         * @param {string} entityId ID of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntity(entityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEntity(entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific entity
         * @summary Get entity by ID
         * @param {string} entityId ID of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(entityId: string, options?: RawAxiosRequestConfig): AxiosPromise<Entity> {
            return localVarFp.getEntity(entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all entities with pagination
         * @summary List entities
         * @param {ListEntitiesOrderEnum} [order] Sort order for results
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [paginationToken] Token for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities(order?: ListEntitiesOrderEnum, limit?: number, paginationToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListEntities200Response> {
            return localVarFp.listEntities(order, limit, paginationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing entity
         * @summary Update entity
         * @param {string} entityId ID of the entity
         * @param {EntityUpdate} entityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity(entityId: string, entityUpdate: EntityUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Entity> {
            return localVarFp.updateEntity(entityId, entityUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI {
    /**
     * Create a new entity in Monite
     * @summary Create entity
     * @param {EntityCreate} entityCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntity(entityCreate: EntityCreate, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).createEntity(entityCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an entity
     * @summary Delete entity
     * @param {string} entityId ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntity(entityId: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).deleteEntity(entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific entity
     * @summary Get entity by ID
     * @param {string} entityId ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntity(entityId: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).getEntity(entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all entities with pagination
     * @summary List entities
     * @param {ListEntitiesOrderEnum} [order] Sort order for results
     * @param {number} [limit] Maximum number of results to return
     * @param {string} [paginationToken] Token for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public listEntities(order?: ListEntitiesOrderEnum, limit?: number, paginationToken?: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).listEntities(order, limit, paginationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing entity
     * @summary Update entity
     * @param {string} entityId ID of the entity
     * @param {EntityUpdate} entityUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntity(entityId: string, entityUpdate: EntityUpdate, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).updateEntity(entityId, entityUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListEntitiesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListEntitiesOrderEnum = typeof ListEntitiesOrderEnum[keyof typeof ListEntitiesOrderEnum];


/**
 * EntitySettingsApi - axios parameter creator
 * @export
 */
export const EntitySettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get entity settings
         * @summary Get entity settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitySettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/entity-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update entity settings
         * @summary Update entity settings
         * @param {MoniteEntitySettings} moniteEntitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntitySettings: async (moniteEntitySettings: MoniteEntitySettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteEntitySettings' is not null or undefined
            assertParamExists('updateEntitySettings', 'moniteEntitySettings', moniteEntitySettings)
            const localVarPath = `/v1/entity-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteEntitySettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitySettingsApi - functional programming interface
 * @export
 */
export const EntitySettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitySettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get entity settings
         * @summary Get entity settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitySettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteEntitySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitySettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitySettingsApi.getEntitySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update entity settings
         * @summary Update entity settings
         * @param {MoniteEntitySettings} moniteEntitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntitySettings(moniteEntitySettings: MoniteEntitySettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteEntitySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntitySettings(moniteEntitySettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitySettingsApi.updateEntitySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntitySettingsApi - factory interface
 * @export
 */
export const EntitySettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitySettingsApiFp(configuration)
    return {
        /**
         * Get entity settings
         * @summary Get entity settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitySettings(options?: RawAxiosRequestConfig): AxiosPromise<MoniteEntitySettings> {
            return localVarFp.getEntitySettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Update entity settings
         * @summary Update entity settings
         * @param {MoniteEntitySettings} moniteEntitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntitySettings(moniteEntitySettings: MoniteEntitySettings, options?: RawAxiosRequestConfig): AxiosPromise<MoniteEntitySettings> {
            return localVarFp.updateEntitySettings(moniteEntitySettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitySettingsApi - object-oriented interface
 * @export
 * @class EntitySettingsApi
 * @extends {BaseAPI}
 */
export class EntitySettingsApi extends BaseAPI {
    /**
     * Get entity settings
     * @summary Get entity settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitySettingsApi
     */
    public getEntitySettings(options?: RawAxiosRequestConfig) {
        return EntitySettingsApiFp(this.configuration).getEntitySettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update entity settings
     * @summary Update entity settings
     * @param {MoniteEntitySettings} moniteEntitySettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitySettingsApi
     */
    public updateEntitySettings(moniteEntitySettings: MoniteEntitySettings, options?: RawAxiosRequestConfig) {
        return EntitySettingsApiFp(this.configuration).updateEntitySettings(moniteEntitySettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PayablesApi - axios parameter creator
 * @export
 */
export const PayablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new payable
         * @summary Create payable
         * @param {MonitePayableCreate} monitePayableCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayable: async (monitePayableCreate: MonitePayableCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitePayableCreate' is not null or undefined
            assertParamExists('createPayable', 'monitePayableCreate', monitePayableCreate)
            const localVarPath = `/v1/payables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(monitePayableCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all payables
         * @summary List payables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayablesApi - functional programming interface
 * @export
 */
export const PayablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new payable
         * @summary Create payable
         * @param {MonitePayableCreate} monitePayableCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayable(monitePayableCreate: MonitePayableCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitePayableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayable(monitePayableCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayablesApi.createPayable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all payables
         * @summary List payables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MonitePayableResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayablesApi.listPayables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PayablesApi - factory interface
 * @export
 */
export const PayablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayablesApiFp(configuration)
    return {
        /**
         * Create a new payable
         * @summary Create payable
         * @param {MonitePayableCreate} monitePayableCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayable(monitePayableCreate: MonitePayableCreate, options?: RawAxiosRequestConfig): AxiosPromise<MonitePayableResponse> {
            return localVarFp.createPayable(monitePayableCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List all payables
         * @summary List payables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayables(options?: RawAxiosRequestConfig): AxiosPromise<Array<MonitePayableResponse>> {
            return localVarFp.listPayables(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayablesApi - object-oriented interface
 * @export
 * @class PayablesApi
 * @extends {BaseAPI}
 */
export class PayablesApi extends BaseAPI {
    /**
     * Create a new payable
     * @summary Create payable
     * @param {MonitePayableCreate} monitePayableCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayablesApi
     */
    public createPayable(monitePayableCreate: MonitePayableCreate, options?: RawAxiosRequestConfig) {
        return PayablesApiFp(this.configuration).createPayable(monitePayableCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all payables
     * @summary List payables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayablesApi
     */
    public listPayables(options?: RawAxiosRequestConfig) {
        return PayablesApiFp(this.configuration).listPayables(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectSettingsApi - axios parameter creator
 * @export
 */
export const ProjectSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get project settings
         * @summary Get project settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/project/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project settings
         * @summary Update project settings
         * @param {MoniteProjectSettings} moniteProjectSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings: async (moniteProjectSettings: MoniteProjectSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteProjectSettings' is not null or undefined
            assertParamExists('updateProjectSettings', 'moniteProjectSettings', moniteProjectSettings)
            const localVarPath = `/v1/project/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteProjectSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSettingsApi - functional programming interface
 * @export
 */
export const ProjectSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get project settings
         * @summary Get project settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteProjectSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSettingsApi.getProjectSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update project settings
         * @summary Update project settings
         * @param {MoniteProjectSettings} moniteProjectSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectSettings(moniteProjectSettings: MoniteProjectSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteProjectSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectSettings(moniteProjectSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSettingsApi.updateProjectSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectSettingsApi - factory interface
 * @export
 */
export const ProjectSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSettingsApiFp(configuration)
    return {
        /**
         * Get project settings
         * @summary Get project settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(options?: RawAxiosRequestConfig): AxiosPromise<MoniteProjectSettings> {
            return localVarFp.getProjectSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Update project settings
         * @summary Update project settings
         * @param {MoniteProjectSettings} moniteProjectSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(moniteProjectSettings: MoniteProjectSettings, options?: RawAxiosRequestConfig): AxiosPromise<MoniteProjectSettings> {
            return localVarFp.updateProjectSettings(moniteProjectSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSettingsApi - object-oriented interface
 * @export
 * @class ProjectSettingsApi
 * @extends {BaseAPI}
 */
export class ProjectSettingsApi extends BaseAPI {
    /**
     * Get project settings
     * @summary Get project settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsApi
     */
    public getProjectSettings(options?: RawAxiosRequestConfig) {
        return ProjectSettingsApiFp(this.configuration).getProjectSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update project settings
     * @summary Update project settings
     * @param {MoniteProjectSettings} moniteProjectSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsApi
     */
    public updateProjectSettings(moniteProjectSettings: MoniteProjectSettings, options?: RawAxiosRequestConfig) {
        return ProjectSettingsApiFp(this.configuration).updateProjectSettings(moniteProjectSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReceivablesApi - axios parameter creator
 * @export
 */
export const ReceivablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new receivable
         * @summary Create receivable
         * @param {MoniteReceivableCreate} moniteReceivableCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceivable: async (moniteReceivableCreate: MoniteReceivableCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteReceivableCreate' is not null or undefined
            assertParamExists('createReceivable', 'moniteReceivableCreate', moniteReceivableCreate)
            const localVarPath = `/v1/receivables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteReceivableCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all receivables
         * @summary List receivables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/receivables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceivablesApi - functional programming interface
 * @export
 */
export const ReceivablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReceivablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new receivable
         * @summary Create receivable
         * @param {MoniteReceivableCreate} moniteReceivableCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReceivable(moniteReceivableCreate: MoniteReceivableCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteReceivableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReceivable(moniteReceivableCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceivablesApi.createReceivable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all receivables
         * @summary List receivables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceivables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MoniteReceivableResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceivables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceivablesApi.listReceivables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReceivablesApi - factory interface
 * @export
 */
export const ReceivablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReceivablesApiFp(configuration)
    return {
        /**
         * Create a new receivable
         * @summary Create receivable
         * @param {MoniteReceivableCreate} moniteReceivableCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceivable(moniteReceivableCreate: MoniteReceivableCreate, options?: RawAxiosRequestConfig): AxiosPromise<MoniteReceivableResponse> {
            return localVarFp.createReceivable(moniteReceivableCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List all receivables
         * @summary List receivables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivables(options?: RawAxiosRequestConfig): AxiosPromise<Array<MoniteReceivableResponse>> {
            return localVarFp.listReceivables(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReceivablesApi - object-oriented interface
 * @export
 * @class ReceivablesApi
 * @extends {BaseAPI}
 */
export class ReceivablesApi extends BaseAPI {
    /**
     * Create a new receivable
     * @summary Create receivable
     * @param {MoniteReceivableCreate} moniteReceivableCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivablesApi
     */
    public createReceivable(moniteReceivableCreate: MoniteReceivableCreate, options?: RawAxiosRequestConfig) {
        return ReceivablesApiFp(this.configuration).createReceivable(moniteReceivableCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all receivables
     * @summary List receivables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceivablesApi
     */
    public listReceivables(options?: RawAxiosRequestConfig) {
        return ReceivablesApiFp(this.configuration).listReceivables(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new role
         * @summary Create role
         * @param {MoniteRole} moniteRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (moniteRole: MoniteRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteRole' is not null or undefined
            assertParamExists('createRole', 'moniteRole', moniteRole)
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all roles
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new role
         * @summary Create role
         * @param {MoniteRole} moniteRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(moniteRole: MoniteRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(moniteRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all roles
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MoniteRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Create a new role
         * @summary Create role
         * @param {MoniteRole} moniteRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(moniteRole: MoniteRole, options?: RawAxiosRequestConfig): AxiosPromise<MoniteRoleResponse> {
            return localVarFp.createRole(moniteRole, options).then((request) => request(axios, basePath));
        },
        /**
         * List all roles
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<MoniteRoleResponse>> {
            return localVarFp.listRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Create a new role
     * @summary Create role
     * @param {MoniteRole} moniteRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(moniteRole: MoniteRole, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(moniteRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all roles
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VATIDsApi - axios parameter creator
 * @export
 */
export const VATIDsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new VAT ID
         * @summary Create VAT ID
         * @param {MoniteVatId} moniteVatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatId: async (moniteVatId: MoniteVatId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteVatId' is not null or undefined
            assertParamExists('createVatId', 'moniteVatId', moniteVatId)
            const localVarPath = `/v1/vat-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteVatId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all VAT IDs
         * @summary List VAT IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVatIds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vat-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VATIDsApi - functional programming interface
 * @export
 */
export const VATIDsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VATIDsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new VAT ID
         * @summary Create VAT ID
         * @param {MoniteVatId} moniteVatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVatId(moniteVatId: MoniteVatId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteVatId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVatId(moniteVatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VATIDsApi.createVatId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all VAT IDs
         * @summary List VAT IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVatIds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MoniteVatId>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVatIds(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VATIDsApi.listVatIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VATIDsApi - factory interface
 * @export
 */
export const VATIDsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VATIDsApiFp(configuration)
    return {
        /**
         * Create a new VAT ID
         * @summary Create VAT ID
         * @param {MoniteVatId} moniteVatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatId(moniteVatId: MoniteVatId, options?: RawAxiosRequestConfig): AxiosPromise<MoniteVatId> {
            return localVarFp.createVatId(moniteVatId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all VAT IDs
         * @summary List VAT IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVatIds(options?: RawAxiosRequestConfig): AxiosPromise<Array<MoniteVatId>> {
            return localVarFp.listVatIds(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VATIDsApi - object-oriented interface
 * @export
 * @class VATIDsApi
 * @extends {BaseAPI}
 */
export class VATIDsApi extends BaseAPI {
    /**
     * Create a new VAT ID
     * @summary Create VAT ID
     * @param {MoniteVatId} moniteVatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VATIDsApi
     */
    public createVatId(moniteVatId: MoniteVatId, options?: RawAxiosRequestConfig) {
        return VATIDsApiFp(this.configuration).createVatId(moniteVatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all VAT IDs
     * @summary List VAT IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VATIDsApi
     */
    public listVatIds(options?: RawAxiosRequestConfig) {
        return VATIDsApiFp(this.configuration).listVatIds(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workflow
         * @summary Create workflow
         * @param {MoniteWorkflow} moniteWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (moniteWorkflow: MoniteWorkflow, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniteWorkflow' is not null or undefined
            assertParamExists('createWorkflow', 'moniteWorkflow', moniteWorkflow)
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moniteWorkflow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all workflows
         * @summary List workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new workflow
         * @summary Create workflow
         * @param {MoniteWorkflow} moniteWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(moniteWorkflow: MoniteWorkflow, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoniteWorkflowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(moniteWorkflow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all workflows
         * @summary List workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflows(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MoniteWorkflowResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflows(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.listWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Create a new workflow
         * @summary Create workflow
         * @param {MoniteWorkflow} moniteWorkflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(moniteWorkflow: MoniteWorkflow, options?: RawAxiosRequestConfig): AxiosPromise<MoniteWorkflowResponse> {
            return localVarFp.createWorkflow(moniteWorkflow, options).then((request) => request(axios, basePath));
        },
        /**
         * List all workflows
         * @summary List workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(options?: RawAxiosRequestConfig): AxiosPromise<Array<MoniteWorkflowResponse>> {
            return localVarFp.listWorkflows(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Create a new workflow
     * @summary Create workflow
     * @param {MoniteWorkflow} moniteWorkflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflow(moniteWorkflow: MoniteWorkflow, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflow(moniteWorkflow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all workflows
     * @summary List workflows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflows(options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).listWorkflows(options).then((request) => request(this.axios, this.basePath));
    }
}



